# generate_dispatcher.py
import itertools


def generate_search_space():
    """Generates a large, valid search space for GEMM kernels."""
    space = set()
    tile_m_opts = [4, 8, 16, 32, 64, 128]
    tile_n_opts = [4, 8, 16, 32, 64, 128, 256]
    tile_k_opts = [4, 8, 16, 32, 64]
    MAX_THREADS_PER_BLOCK = 1024
    MAX_SHARED_MEM_BYTES = 48 * 1024
    for tm, tn, tk in itertools.product(tile_m_opts, tile_n_opts, tile_k_opts):
        bx = tn
        by = tm
        if bx * by > MAX_THREADS_PER_BLOCK:
            continue
        shared_mem_needed = (tm * tk + tk * tn) * 4
        if shared_mem_needed > MAX_SHARED_MEM_BYTES:
            continue
        space.add((tm, tn, tk, bx, by))
    return sorted(list(space))


CONFIGURATIONS = generate_search_space()


def write_configs_to_file():
    """Writes the generated configurations to a text file for C++ to read."""
    with open("configurations.txt", "w") as f:
        for config in CONFIGURATIONS:
            f.write(f"{config[0]} {config[1]} {config[2]} {config[3]} {config[4]}\n")


def generate_header():
    header_content = """
#pragma once
#include "KernelConfig.h"
#include "kernel.cuh"
#include <iostream>
// THIS FILE IS AUTO-GENERATED BY generate_dispatcher.py
// DO NOT EDIT MANUALLY
#define CUDA_CHECK(call) \\
  do { \\
    cudaError_t err = call; \\
    if (err != cudaSuccess) { \\
      fprintf(stderr, "CUDA Error at %s:%d: %s\\n", __FILE__, __LINE__, \\
              cudaGetErrorString(err)); \\
      exit(EXIT_FAILURE); \\
    } \\
  } while (0)
void launch_kernel_with_config(const KernelConfig &config, float *d_C,
                              const float *d_A, const float *d_B, int M, int N,
                              int K) {
    dim3 blockDim(config.BLOCK_DIM_X, config.BLOCK_DIM_Y);
    dim3 gridDim((N + config.TILE_N - 1) / config.TILE_N,
                 (M + config.TILE_M - 1) / config.TILE_M);
    size_t shared_size = (static_cast<size_t>(config.TILE_M) * config.TILE_K +
                          static_cast<size_t>(config.TILE_K) * config.TILE_N) *
                         sizeof(float);
"""
    first = True
    for tm, tn, tk, bx, by in CONFIGURATIONS:
        condition = f"config.TILE_M == {tm} && config.TILE_N == {tn} && config.TILE_K == {tk} && config.BLOCK_DIM_X == {bx} && config.BLOCK_DIM_Y == {by}"
        launch = f"    matrix_multiply_kernel<{tm}, {tn}, {tk}, {bx}, {by}><<<gridDim, blockDim, shared_size>>>(d_C, d_A, d_B, M, N, K);"
        if first:
            header_content += f"    if ({condition}) {{\n{launch}\n    }}"
            first = False
        else:
            header_content += f"    else if ({condition}) {{\n{launch}\n    }}"
    header_content += """
    else {
        std::cerr << "FATAL: Unsupported kernel configuration: " << config.toString() << std::endl;
        exit(1);
    }
    CUDA_CHECK(cudaGetLastError());
}
"""
    with open("Evaluator_dispatcher.h", "w") as f:
        f.write(header_content)


if __name__ == "__main__":
    print(f"Generated a search space of {len(CONFIGURATIONS)} configurations.")
    write_configs_to_file()
    generate_header()
    print("Generated configurations.txt and Evaluator_dispatcher.h successfully.")
